import datetime as dt
import math
import random

import torch

import matcha.utils.monotonic_align as monotonic_align  # pylint: disable=consider-using-from-import
from matcha import utils
from matcha.models.baselightningmodule import BaseLightningClass
from matcha.models.components.duration_predictors import DP
from matcha.models.components.flow_matching import CFM
from matcha.models.components.text_encoder import TextEncoder
from matcha.utils.model import (
    denormalize,
    fix_len_compatibility,
    generate_path,
    sequence_mask,
)

log = utils.get_pylogger(__name__)


class MatchaTTS(BaseLightningClass):  # ðŸµ
    def __init__(
        self,
        n_vocab,
        n_spks,
        spk_emb_dim,
        n_feats,
        encoder,
        duration_predictor,
        decoder,
        cfm,
        data_statistics,
        out_size,
        optimizer=None,
        scheduler=None,
        use_precomputed_durations=False,
    ):
        super().__init__()

        self.save_hyperparameters(logger=False)

        self.n_vocab = n_vocab
        self.n_spks = n_spks
        self.spk_emb_dim = spk_emb_dim
        self.n_feats = n_feats
        self.out_size = out_size
        self.use_precomputed_durations = use_precomputed_durations

        if n_spks > 1:
            self.spk_emb = torch.nn.Embedding(n_spks, spk_emb_dim)
            self.dur_spk_emb = torch.nn.Embedding(n_spks, spk_emb_dim)

        self.encoder = TextEncoder(
            encoder.encoder_type,
            encoder.encoder_params,
            n_vocab,
            n_spks,
            spk_emb_dim,
        )

        self.dp = DP(duration_predictor)

        self.decoder = CFM(
            in_channels=336,
            out_channel=encoder.encoder_params.n_feats,
            cfm_params=cfm,
            decoder_params=decoder,
            n_spks=n_spks,
            spk_emb_dim=spk_emb_dim,
        )


        # uncondition input for cfg
        self.fake_speaker = torch.nn.Parameter(torch.zeros(1, spk_emb_dim))
        self.fake_content = torch.nn.Parameter(torch.zeros(1, 256, 1))

        self.cfg_dropout = 0.1
#        self.cfg_dropout = 0.0

        for param in self.parameters():
            param.requires_grad = False
        for param in self.decoder.parameters():
            param.requires_grad = True

        torch.set_printoptions(precision=3)
        torch.set_printoptions(profile='full')
        torch.set_printoptions(linewidth=100000)

        self.update_data_statistics(data_statistics)

    @torch.inference_mode()
    def synthesise(self, x, x_lengths, n_timesteps, temperature=1.0, dp_temperature=0.7, spks=None, bert=None, length_scale=1.0, phone_duration_extra=None):
        """
        Generates mel-spectrogram from text. Returns:
            1. encoder outputs
            2. decoder outputs
            3. generated alignment

        Args:
            x (torch.Tensor): batch of texts, converted to a tensor with phoneme embedding ids.
                shape: (batch_size, max_text_length)
            x_lengths (torch.Tensor): lengths of texts in batch.
                shape: (batch_size,)
            n_timesteps (int): number of steps to use for reverse diffusion in decoder.
            temperature (float, optional): controls variance of terminal distribution.
            spks (bool, optional): speaker ids.
                shape: (batch_size,)
            length_scale (float, optional): controls speech pace.
                Increase value to slow down generated speech and vice versa.

        Returns:
            dict: {
                "encoder_outputs": torch.Tensor, shape: (batch_size, n_feats, max_mel_length),
                # Average mel spectrogram generated by the encoder
                "decoder_outputs": torch.Tensor, shape: (batch_size, n_feats, max_mel_length),
                # Refined mel spectrogram improved by the CFM
                "attn": torch.Tensor, shape: (batch_size, max_text_length, max_mel_length),
                # Alignment map between text and mel spectrogram
                "mel": torch.Tensor, shape: (batch_size, n_feats, max_mel_length),
                # Denormalized mel spectrogram
                "mel_lengths": torch.Tensor, shape: (batch_size,),
                # Lengths of mel spectrograms
                "rtf": float,
                # Real-time factor
        """
        # For RTF computation
        t = dt.datetime.now()

        spks_orig = spks
        x_orig = x
        if self.n_spks > 1:
            # Get speaker embedding
            spks = self.spk_emb(spks.long())
        dur_spks = self.dur_spk_emb(spks_orig.long())

        # Get encoder_outputs `mu_x` and log-scaled token durations `logw`
        x, x_mel, mu_mel, x_dp, mu_dp, x_mask = self.encoder(x, x_lengths, spks, dur_spks, bert)


        # Get log-scaled token durations `logw`
        logw = self.dp(mu_dp, x_mask, dp_temperature)

        logw = torch.sigmoid(logw).sum(axis=1, keepdim=True)

        if phone_duration_extra == None:
            phone_duration_extra = torch.zeros(logw.size(), dtype=torch.float32, device=logw.device).squeeze(0)
        else:
            logw = torch.where(phone_duration_extra == 0, logw, phone_duration_extra)

        w_round = torch.round(logw * length_scale).clamp(min=1)

#        from matcha.text import _id_to_symbol
#        start = 0
#        for i in range(x_lengths[0]):
#             print (f"{_id_to_symbol[x_orig[0,0,i].item()]} {start * 256. / 22050:.4f} {logw[0,0,i].item():.4f}")
#             start = start + w_round[0,0,i].item()

        y_lengths = torch.sum(w_round, [1, 2]).long()
        y_max_length = y_lengths.max()
        y_max_length_ = fix_len_compatibility(y_max_length)

        # Using obtained durations `w` construct alignment map `attn`
        y_mask = sequence_mask(y_lengths, y_max_length_).unsqueeze(1).to(x_mask.dtype)
        attn_mask = x_mask.unsqueeze(-1) * y_mask.unsqueeze(2)
        attn = generate_path(w_round.squeeze(1), attn_mask.squeeze(1)).unsqueeze(1)

        # Align encoded text and get mu_y
        mu_y = torch.matmul(attn.squeeze(1).transpose(1, 2), x.transpose(1, 2))
        mu_y = mu_y.transpose(1, 2)

        # Align encoded text with mel-spectrogram and get mu_y segment
        pau_mel = torch.matmul(attn.squeeze(1).transpose(1, 2), phone_duration_extra.unsqueeze(0).transpose(1,2)).transpose(1, 2)
#        print (pau_mel)

        # Align encoded text with mel-spectrogram and get mu_y segment
        mu_y_mel = torch.matmul(attn.squeeze(1).transpose(1, 2), mu_mel.transpose(1, 2))
        mu_y_mel = mu_y_mel.transpose(1, 2)
        encoder_outputs = mu_y_mel[:, :, :y_max_length]

        # Generate sample tracing the probability flow
        decoder_outputs = self.decoder(mu_y, y_mask, n_timesteps, temperature, spks, None, self.fake_speaker, self.fake_content)
        decoder_outputs = decoder_outputs[:, :, :y_max_length]

        sil_mel = decoder_outputs[0, :, 0]

#        print (sil_mel)
#
#        for i in range(y_max_length):
#           if pau_mel[0, 0, i] > 0:
#               decoder_outputs[0, :, i] = sil_mel

        sil_mel_expanded = sil_mel.view(1, -1, 1)
        condition = pau_mel[:, :, :y_max_length] > 0
        condition = condition.expand(-1, decoder_outputs.size(1), -1)
        decoder_outputs = torch.where(condition, sil_mel_expanded, decoder_outputs)


        t = (dt.datetime.now() - t).total_seconds()
        rtf = t * 22050 / (decoder_outputs.shape[-1] * 256)

        return {
            "encoder_outputs": encoder_outputs,
            "decoder_outputs": decoder_outputs,
            "attn": attn[:, :, :y_max_length],
            "mel": denormalize(decoder_outputs, self.mel_mean, self.mel_std),
            "mel_enc": denormalize(encoder_outputs, self.mel_mean, self.mel_std),
            "mel_lengths": y_lengths,
            "rtf": rtf,
        }

    def forward(self, x, x_lengths, y, y_lengths, spks=None, bert=None, out_size=None, cond=None, durations=None):
        """
        Computes 3 losses:
            1. duration loss: loss between predicted token durations and those extracted by Monotinic Alignment Search (MAS).
            2. prior loss: loss between mel-spectrogram and encoder outputs.
            3. flow matching loss: loss between mel-spectrogram and decoder outputs.

        Args:
            x (torch.Tensor): batch of texts, converted to a tensor with phoneme embedding ids.
                shape: (batch_size, max_text_length)
            x_lengths (torch.Tensor): lengths of texts in batch.
                shape: (batch_size,)
            y (torch.Tensor): batch of corresponding mel-spectrograms.
                shape: (batch_size, n_feats, max_mel_length)
            y_lengths (torch.Tensor): lengths of mel-spectrograms in batch.
                shape: (batch_size,)
            out_size (int, optional): length (in mel's sampling rate) of segment to cut, on which decoder will be trained.
                Should be divisible by 2^{num of UNet downsamplings}. Needed to increase batch size.
            spks (torch.Tensor, optional): speaker ids.
                shape: (batch_size,)
        """

        spks_orig = spks
        spks = self.spk_emb(spks_orig)
        dur_spks = self.dur_spk_emb(spks_orig)
        x_orig = x

#        print (cfg_mask)
#        print (spks)
#        print (spks * cfg_mask)
#        print (~cfg_mask * self.fake_speaker.repeat(y.size(0), 1))
#        print (self.fake_speaker)

        # Get encoder_outputs `mu_x` and log-scaled token durations `logw`
        x, x_mel, mu_mel, x_dp, mu_dp, x_mask = self.encoder(x, x_lengths, spks, dur_spks, bert)

        y_max_length = y.shape[-1]
        y_mask = sequence_mask(y_lengths, y_max_length).unsqueeze(1).to(x_mask)
        attn_mask = x_mask.unsqueeze(-1) * y_mask.unsqueeze(2)


        if self.use_precomputed_durations:
            attn = generate_path(durations.squeeze(1), attn_mask.squeeze(1))
#        else:
#            # Use MAS to find most likely alignment `attn` between text and mel-spectrogram
#            with torch.no_grad():
#                const = -0.5 * math.log(2 * math.pi) * self.n_feats
#                factor = -0.5 * torch.ones(mu_x.shape, dtype=mu_x.dtype, device=mu_x.device)
#                y_square = torch.matmul(factor.transpose(1, 2), y**2)
#                y_mu_double = torch.matmul(2.0 * (factor * mu_x).transpose(1, 2), y)
#                mu_square = torch.sum(factor * (mu_x**2), 1).unsqueeze(-1)
#                log_prior = y_square - y_mu_double + mu_square + const
#
#                attn = monotonic_align.maximum_path(log_prior, attn_mask.squeeze(1))
#                attn = attn.detach()  # b, t_text, T_mel

        # Compute loss between predicted log-scaled durations and those obtained from MAS
        # refered to as prior loss in the paper
        #logw_ = torch.log(1e-8 + torch.sum(attn.unsqueeze(1), -1)) * x_mask
        logw_ = torch.sum(attn.unsqueeze(1), -1) * x_mask

        from matcha.text import _id_to_symbol
#        start = 0
#        for i in range(x_lengths[0]):
#             print (f"{_id_to_symbol[x_orig[0,0,i].item()]} {start * 256. / 22050:.4f} {start} {int(logw_[0,0,i].item())}")
#             start = start + logw_[0,0,i].item()

        # dur_loss = self.dp.compute_loss(logw_, mu_dp, x_mask)
        dur_loss = 0

        # Align encoded text with mel-spectrogram and get mu_y segment
        mu_y = torch.matmul(attn.squeeze(1).transpose(1, 2), x.transpose(1, 2))
        mu_y = mu_y.transpose(1, 2)

        # Align encoded text with mel-spectrogram and get mu_y segment
        # mu_y_mel = torch.matmul(attn.squeeze(1).transpose(1, 2), mu_mel.transpose(1, 2))
        # mu_y_mel = mu_y_mel.transpose(1, 2)
        # prior_loss = torch.sum(((y - mu_y_mel) ** 2) * y_mask)
        # prior_loss = prior_loss / (torch.sum(y_mask) * self.n_feats)
        prior_loss = 0

        # CFG
        # mask content information for better diversity for flow-matching, separate masking for speaker and content

        cfg_rand = torch.rand(y.size(0), 1, device=y.device)
        cfg_mask = (cfg_rand > self.cfg_dropout)
        spks = spks * cfg_mask + ~cfg_mask * self.fake_speaker.repeat(y.size(0), 1)
        cfg_mask = cfg_mask.unsqueeze(-1)
        mu_y_masked = mu_y  * cfg_mask + ~cfg_mask * self.fake_content.repeat(mu_y.size(0), 1, mu_y.size(-1))

        # Compute loss of the decoder
        diff_loss, _ = self.decoder.compute_loss(x1=y, mask=y_mask, mu=mu_y_masked, spks=spks, cond=cond)
        # diff_loss = 0

        return dur_loss, prior_loss, diff_loss, attn
